[["index.html", "A Primer of Ecosystem Modeling 1 Prerequisites 1.1 A couple of other useful citations", " A Primer of Ecosystem Modeling Hank Stevens, BIO 672 2021-01-21 1 Prerequisites For this R primer, you’ll need to read several chapters of Soetaert and Herman (2009) which are available on the Canvas website. Their book is an excellent source for those interested in ecosystem modeling. We will use bits of it along with this online text to get a little more comfortable with ecosystem processes and models. 1.1 A couple of other useful citations Ten simple rules for biologists learning to program. PLoS Computional Biology 14(1): e1005871. https://doi.org/10.1371/journal.pcbi.1005871 Ten simple rules for tackling your first mathematical models: A guide for graduate students by graduate students. PLOS Computational Biology 17(1): e1008539. https://doi.org/10.1371/journal.pcbi.1008539 References "],["intro.html", "2 Introduction to ecosystem modeling 2.1 Why models? 2.2 What’s an ecosystem? 2.3 What’s a model? 2.4 Steps in modeling 2.5 An example in R", " 2 Introduction to ecosystem modeling Reading: pp. 1-17, (Chapters 1, 2; Soetaert and Hermann 2009) In this course, we’ll cover the very basics of ecosystem modeling. There are several goals I have for you, the reader. I hope the you, become more fluent in the discipline of ecosystem ecology; that you understand and can use basic terminology, and can identify quantitative pieces of the literature you read, and presentations you hear and see; understand and describe the quantitative and qualitative features of ecosystem dynamics and models of those dynamics; assess the relative merits of different modeling approaches and different mathematical formalisms of those apporaches; create models of ecosystem dynamics of your own; write R code to implement ecosystem models. To do all this, the following text relies heavily on selected secondary sources including Soetaert and Herman (2009) and Haefner (1996). I also cite selected primary soruces where appropriate. 2.1 Why models? In general, models are simplifications of reality. Useful models capture something useful about the reality we are interested in. A road map is a useful model of a road network. It captures just what we need. We model to aid understanding, because, at some level, the model is a quantitative and qualitative explanation for some phenomenon (Fig. 2.1). We can use models to test hypotheses, guide experiments, and predict manage ecosystems and populations (Soetaert and Herman 2009). Figure 2.1: We use conceptual and mathematical models to interpret reality. (Fig. 1.3 in Soetaert and Hermann, 2009). 2.2 What’s an ecosystem? You can find definitions of an ecosystem elsewhere, but here we want to emphasize the abstraction of that ecosystem (Fig. 2.2). We will think of an ecosystem as a set of one or more compartments containing some mass of an element of interest, such as carbon or nitrogen. That element is the currency of the ecosystem. These compartments (aka pools, stocks) are connected by fluxes, or flows, the transfer of some mass of the element. When these transfers come from outside the ecosystem entirely, we refer to them as imports. When the transfer exits the system entirely, we refer to it as an exports. Figure 2.2: An ecosystem perspective of lake, in terms of phosphorus (Carpenter et al. 1992). Boxes are ecosystem compartments and the quantities are pools (a.k.a. stocks, units are mass per unit area or volume). Arrows are fluxes (units are mass per unit time. Ecosystem fluxes or flows are influenced by state factors such as temperature, time, or disturbance which act as constraints that can limit or speed up the fluxes or determine the current states of the variables (Fig. 2.3). Figure 2.3: The current state of an ecosystem depends on state factors (Chapin III, Matson, and Mooney 2002). We can describe an ecosystem as a set of pools or compartments, connected by fluxes, that is, transfers of energy or materials among pools. In Fig. 2.2, all pools are receiving imports from outside the system, represented by arrows coming from the amorphous cloud. All pools save dissolved P appear to export P back out. Dissolved P is receiving fluxes from all the animals in the system, and losing P to seston, which is primarily phytoplankton. 2.3 What’s a model? You’ve already seen ecosystem models. An ecosystem model consists of the compartments and fluxes we saw above. We refer to the currencies in different compartments as variables because they can vary or change through time. We use mathematical equations and computational controls to represent fluxes between compartments. In the equations, there are constants that we call parameters that control the rate of these fluxes. We describe an ecosystem using balance equations for each pool. A balance equation is simply a bookkeeping or budgeting device to keep track of fluxes: \\[\\mathrm{Change~in~pool} = \\mathrm{Sources - Sinks}\\] As models increase in complexity, we usually use differential equations, or time derivatives, to represent the balance equation for each pool or state variable in a model. For instance, the dissolved P in Fig. 2.2 might look like \\[\\frac{dD}{dt} = I + e_HH + e_N N + e_1 F_1 + e_2 F_2 - u_SS\\] where \\(D\\) is the amount of P in the dissolved pool, perhaps in mg m\\(^{-2}\\), \\(I\\) is import, or source, from outside the system (dust? lake inflow?), and \\(H\\), \\(N\\), \\(F_1\\), and \\(F_2\\) are the other pools. The lower case letters are parameters or rate constants that are the mass-specific fluxes. The units of \\(dD/dt\\) are mg m\\(^{-2}\\) d$^{-1}, and so each term (e.g., \\(I\\) or \\(e_H H\\)) in the equation must also have these same units. units of \\(e_H H\\) must be mg m\\(^{-2}\\) d\\(^{-1}\\). units of \\(H\\) are mg m\\(^{-2}\\). Ergo, units of \\(e_H\\) are d\\(^{-1}\\). More intuitively, the units of these rate constants are mg m\\(^{-2} d\\)^{-1}$ per mg m\\(^{-2} in the lake. Note the quantities cancel out, and we are left with d\\)^{-1}$. See Soetaert and Herman (2009) section 2.1.4 for further explanation. One nice feature of ecosystem ecology and ecosystem models is the emphasis on the conservation of mass and energy. We aim to track where everything comes from and where it goes. If we add up all of the rates of change for each pool, we should see that most of them concel out, and we are left with only imports and exports. Doing this summation will tell us whether our model makes sense or we made a mistake. If we did not make any mistakes, it will tell us whether the entire system is a net sink or source of our currency. For instance, after simplifying the lake ecosystem model, we would have, \\[\\frac{dD}{dt} + \\frac{dS}{dt} + \\frac{dH}{dt} + \\frac{dN}{dt} + \\frac{dF_1}{dt} + \\frac{dF_2}{dt} = \\ldots \\ldots = \\mathrm{Imports - Exports}\\] See Soetaert and Herman (2009) section 2.1.3 for further explanation. State factors also enter into the model, typically altering the fluxes. For instance, increasing atmospheric temperature might force a predictable change in our rate constants (e.g., \\(e_H\\), \\(u_S\\)) in the above model. Because temperature is an external factor forcing a change to a parameter, we often call its role in a model a forcing function. To review: variables are quantities that change with time, such as the amount of carbon in the atmosphere, or the amount of phosphorus in the primary producers in a lake. Parameters are (typically) constants in equations that quantify how quickly the variables change. Forcing functions represent state factors that we think of as external to the ecosystem compartments. No models apply everywhere, all the time. All models are limited for a specific domain and with specific boundaries. These are the spatial, temporal and conceptual limits on a model. 2.3.1 Other ideas Statistical models (e.g., regression) are concerned with describing patterns and hypothesis testing. Process models (e.g., stock and flow models) are also descriptions of natural systems, but they include more mechanism and seek to describe mechanism and understand process. People sometimes call these mechanistic models. Figure 2.4: A statistical model of aboveground plant biomass as a function of available soil nitrogen. A theory is a well supported hierarchical framework that contains clearly formulated postulates, based on a minimal set of assumptions, from which a set of predictions logically follows (Marquet et al. 2014). Efficient theory is based to as much as possible on first principles, and relies on as few assumptins as possible. In contrast to theory, models are specific implementations of theory and specific descriptions of nature. Remember that in principle, all models are wrong, but some are useful1. Exercise: Ask yourself whether a lake is a carbon sink or a source. Draw an appropriate compartment model to address this question. After having done so, ask yourself what assumptions you’ve made about the temporal and spatial scales. What mechanisms have you included? Why? 2.4 Steps in modeling Soetaert and Herman (2009) identify a series steps that guides model development and ultimately improve understanding and prediction (Fig. 2.5). Figure 2.5: It is helpful to use a series of steps in improving our models. (Figure 1.7 in Soetaert and Hermann, 2009). 2.5 An example in R Here we create a simple model to illustrate some of what we’ve been describing. Consider our lake above, as a whole. We’ll let the imports, \\(I\\), be constant and independent of the amount of the P in the lake. Our exports will depend on the amount of the P in the system-the more P in the system, to more can be exported, that is, a constant fraction, \\(a\\), is exported, \\[\\frac{dP}{dt} = I - a P\\] In R, we write a function for the system of differential equations. lake &lt;- function( time, state_vars, parameters ){ P &lt;- state_vars[1] # state variable(s) with(as.list(parameters), # tell R to look inside &#39;parameters&#39; { dP.dt &lt;- I -a*P # the balance eq. or rate func. return(list(dP.dt)) # return the value of the rate function }) } Next, we tell R what the values of the parameters are that we want. Let’s say the the import is 3 mg m\\(^{-2}\\) d\\(^{-1}\\), and that the fraction (or rate, really) is 0.5 d\\(^{-1}\\), or more intuitively, mg m\\(^{-2}\\) d\\(^{-1}\\) per mg m\\(^{-2}\\) in the lake. Note the quantities cancel out, and we are left with d\\(^{-1}\\). p &lt;- c(I = 10, a = .5) Now the exciting part. We tell R our starting point and what time points we want to integrate for, and then solve the differential equation and have R return the result for the time points we want. After that, we display the first five time points. initial.state &lt;- c(P=1) t &lt;- seq(from=0, to=10, by=1/24) # 10 days, in hourly increments out &lt;- ode(y=initial.state, times = t, func = lake, parms = p) out[1:5,] ## time P ## [1,] 0.00000000 1.000000 ## [2,] 0.04166667 1.391740 ## [3,] 0.08333333 1.775400 ## [4,] 0.12500000 2.151151 ## [5,] 0.16666667 2.519155 Pictures are informative, so here we plot the result. plot(out) In very simple situations, we can solve the equilibrium by hand. By definition, the equilibrium is a state at which the system stops changing, that is, its rate of change is zero. To find a value of \\(P\\) which is an equilibrium, we set the balance equation equal to zero, and solve for \\(P\\): \\[\\frac{dP}{dt} = 0 = I -aP\\] \\[P^* = \\frac{I}{a}\\] By convention, we denote the equilibrium value of \\(P\\) with an asterisk, or “star”, as in “P-star”. We call this the analytical solution. Questions: Is our graph consistent with the analytical prediction of \\(P^*\\)? Determine the units of \\(I\\) and \\(a\\); show your work and explain it to your cat. In more complex systems, we often (typically?) can’t solve for the analytical solution. Instead, we usually run a model for a long period of time, until the state variables stop changing to find the same result. Alternatively, if we have a model of a real ecosystem, we made be interested in its short term dynamics and address any number of questions related to experimental results, making predictions about the consequences of landscape management, or or using a time series to compare different models. References "],["N.html", "3 Describing a nitrogen budget 3.1 Getting started 3.2 First mathematical form for plant uptake 3.3 Paramaterization 3.4 Mathematical solution 3.5 Calibration, take 1 3.6 Budget, take II", " 3 Describing a nitrogen budget Readings: pp. 17-35 (Soetaert and Hermann 2009) Bormann et al. 1977 Figure 3.1: Nitrogen bugdget for a temperate northern hardwood forest (Hubbard Brook Watershed 6, Bormann et al. 1977). Figure 3.2: A simpler compartment model for Hubbard Brook Watershed 6, based on Bormann et al. (1977). 3.1 Getting started (S&amp;H 15-17) For any ecosystem, we want to start with paper and pencil and sketch out the pools and the fluxes that we think are important (see example, Fig. 3.2). Don’t sweat the details yet – you’ll revise it anyway. Go ahead an label the compartments and the fluxes with with both biological and physical processes as well as some simple abstract notation. Write balance equations (S&amp;H, 3, 17-20). For each flux, identify the underlying biological and physical processes. If you don’t completely know, don’t sweat it. Here are the balance equations for Fig. 3.2: Rate of change of vegetation = uptake - exudates and through fall - leaf and root litter loss \\[\\frac{dV}{dt} = f_1 - f_2 - f_3\\] Rate of change in available pool in soil solution = bulk precip + exudates and through fall + net mineralization - uptake - stream export \\[\\frac{dA}{dt} = I_1 + f_2 + f_4 - f_1 - E_1\\] Rate of change in the bound pool = net N fixation + leaf and root litter loss - net mineralization - stream export \\[\\frac{dB}{dt} = I_2 + f_3 - f_4 - E_2\\] Assess the total load or mass budget (S&amp;H, 19-22). For Fig. 3.2, we have \\[\\frac{d\\left(V+A+B\\right)}{dt} = \\frac{dV}{dt} + \\frac{dA}{dt} + \\frac{dB}{dt} = (f_1 - f_2 - f_3) + (I_1 + f_2 + f_4 - f_1 - E_1) + (I_2 + f_3 - f_4 - E_2)\\] \\[\\frac{d\\left(V+A+B\\right)}{dt} = I_1 + I_2 + f_1 - f_1 + f_2 - f_2 + f_3 - f_3 + f_4 - f_4 - E_1 - E_2\\] \\[\\frac{d\\left(V+A+B\\right)}{dt} = I_1 + I_2 - E_1 - E_2\\] From this we see that the total mass budget for this watershed depends simply on import or inputs, and exports or outputs. For each flux, decide which pools directly influence the flux. In a forest, the flux of nitrogen from vegetation to soil will depend enormously on the amount of vegetation present as leaves senesce and fall, fine roots die back, and water leaches nutrients out of leaves and bark. The flux is very unlikely to depend directly on the amount of nitrogen already in the soil. In a lake, the flux of phosphorous from the water column into phytoplankton depends on the amounts of both the amount of phytoplankton and the amount of phosphate in the water at any given instant. For the vegetation pool in Fig. 3.2, we see each flux (\\(f\\)) is a Function (\\(F()\\)) of one or two pools: Uptake: \\(f_1 = F(V,A)\\) Leaf and root litter, and throughfall: \\(f_3 = F(V)\\) Root exudates, and throughfall: \\(f_4 = F(V)\\) Next, we want to represent these fluxes in a mathematical form. 3.2 First mathematical form for plant uptake A common starting point for dynamics depending on two pools is the law of mass action. This states that the reaction rate is proportional the product of the pools. In the case of plant uptake of N, which depends on the amounts of N in the available pool and the vegetation pool, this would be \\(aVA\\), where \\(a\\) is a proportionality constant. In some circumstances, these pools might also have exponents different than one (\\(aV^1A^1\\)), such as \\(aVA^2\\). This occurs in chemistry when a reaction requires two molecules of “A” for each molecule of “V”. It might occur in ecology if a rate depends differentially on A and B. Using the law of mass action for plant uptake, we will describe the fluxes in the simple N budget above (Fig. 3.2) with the following expressions. \\[\\begin{align} \\frac{dV}{dt} &amp;= a_{1}AV - a_{2}V - a_3 V\\\\ \\frac{dA}{dt} &amp;= I_1 + a_{2}V + a_{4}B - a_{5}A - a_{1}AV\\\\ \\frac{dB}{dt} &amp;= I_2 + a_{3}V - a_{4}B - a_{6}B \\end{align}\\] Take the time to identify each term and think about the biology or physics that might govern each term. 3.3 Paramaterization Parameteriztion is what we call assigning numerical values to mathematical parameters. Here, we find initial estimates for the parameters in our model. We use the literature for this purpose (Bormann, Likens, and Melillo 1977). If we have the data (we do) and relatively simple mathematical forms (we do), it is fairly straightforward to estimate parameters. For instance, we decided that net mineralization would be directly proportional to the size of the organic pool, \\(B\\), that is, \\(F_4 = a_4B\\). To calculate \\(a_4\\), we substitute data where we can, and solve what we need. \\[\\begin{align*} F_2 &amp;= a_4 B\\\\ 69.6 &amp;= a_4 4700 \\\\ a_4 &amp;= \\frac{69.6}{4700}\\\\ a_4 &amp;\\approx 0.015 \\end{align*}\\] We use the same approach for second order equations as well. Table 3.1: Parameters, variables, units and estimates for a simplified model of Bormann et al. (1977). All fluxes (\\(dX/dy\\)) are in units of kg ha\\(^{-1}\\) y\\(^{-1}\\). (Note that calculations should not be included in your final table, but are presented here for comparison to your own calculations.) p.or.V units Estimate \\(A, B, V\\) state variables kg ha\\(^{-1}\\) \\(26, 4700, 532\\) \\(a_1\\), uptake rate by V from A (kg ha\\(^{-1}\\))\\(^{-1}\\) y\\(^{-1}\\) \\(79.6 / (26 \\cdot 532) = 0.0058\\) \\(a_2\\), loss rate from V to A y\\(^{-1}\\) \\((6.6 + 0.8) / 532 = 0.014\\) \\(a_3\\), loss rate from V to B (kg ha\\(^{-1}\\))\\(^{-1}\\) y\\(^{-1}\\) \\((54.2 + 2.7 + 0.1 + 6.2 ) / 532 = 0.00022\\) \\(a_4\\), mineralization y\\(^{-1}\\) \\(69.6 / 4700 = 0.015\\) \\(a_5\\), export from A y\\(^{-1}\\) \\(3.9 /26 = 0.15\\) \\(a_6\\), export from B y\\(^{-1}\\) \\(0.1/4700 = 0.000021\\) \\(I_1\\), bulk precip kg ha\\(^{-1}\\) y\\(^{-1}\\) \\(6.5\\) \\(I_2\\), N fixation kg ha\\(^{-1}\\) y\\(^{-1}\\) \\(14.2\\) Enter parameters into R. # Atmospheric inputs ## Precip i1 &lt;- 6.5 ## fixation i2 &lt;- 14.2 # uptake a1 &lt;- 79.6 / (26 * 532) # throughfall and exudates (inorganic) a2 &lt;- (6.6 + 0.8) / 532 # litter, throughfall, exudates (organic) a3 &lt;- (54.2 + 2.7 + 0.1 + 6.2 ) / 532 # net mineralization a4 &lt;- 69.6 / 4700 # export from available a5 &lt;- 3.9 /26 #export from bound a6 &lt;- 0.1/4700 # make a vector params &lt;- c( a1 = a1, a2 = a2, a3 = a3, a4 = a4, a5 = a5, a6 = a6, i1 = i1, i2 = i2) #...and look at it. params ## a1 a2 a3 a4 a5 a6 ## 5.754772e-03 1.390977e-02 1.187970e-01 1.480851e-02 1.500000e-01 2.127660e-05 ## i1 i2 ## 6.500000e+00 1.420000e+01 3.4 Mathematical solution The mathematical solution is the process of making the predictions using our model and our parameters. We solve the model. With simple models, we can sometimes find analytical solutions. For most ecosystem models, we have to solve the models numerically using numerical integration. Here we write a function that includes our system of differential equations. This will allow R to integrate change through time. bormann1 &lt;- function(t, y, p) { # time, vector of state variables and parameters must be in this order # we can use as.list for both the state variables and parameters # a1 = uptake # a2 = loss from veg to avail # a3 = loss from veg to bound # a4 = net mineralization # a5 = export from avail # a6 = export from bound with( as.list( c(y, p) ), { dV.dt &lt;- a1 * A * V - a2 * V - a3 * V dA.dt &lt;- i1 + a2 * V + a4 * B - a1 * A * V - a5 * A dB.dt &lt;- i2 + a3 * V - a4 * B - a6 * B # Here we return a list whose first element is the vector of # rates of change for the state variables. The first element must be these rates, # in the same order as the state variables in y # The second element is the total N in the system return(list( c(dV.dt, dA.dt, dB.dt), total = V + A + B ) )}) } Now that we have the function, we tell R what to do with it. We will define the initial state of the system, and then tell R which time point we want it to return. The initial state of the system is the set of starting values for the state variables. We could choose any values, but I select the values given in Bormann, Likens, and Melillo (1977). initial.state &lt;- c( V = 532, A = 26, B = 4700) 3.5 Calibration, take 1 Calibration, in general, is the process of finding better estimates for our parameters. We can do that by looking into the literature, or by using independent data to estimates parameters directly. If we take a look at the model output (above), we see both differences and similarities with Bormann et al. What are they? What if we run it out longer, say, 100 years? time &lt;- 0:250 out &lt;- ode(y = initial.state, times=time, func=bormann1, parms = params) head(round(out,1)) ## time V A B total ## [1,] 0 532.0 26.0 4700.0 5258.0 ## [2,] 1 540.8 25.8 4708.2 5274.7 ## [3,] 2 548.8 25.5 4717.2 5291.5 ## [4,] 3 556.0 25.2 4727.0 5308.3 ## [5,] 4 562.6 25.0 4737.5 5325.1 ## [6,] 5 568.6 24.8 4748.6 5342.0 #plot(out) Use gather() and ggplot() to make a graph. We use gather() gather multiple columns into one with a new name (value=kg.N), keeping track of the names of the original columns in a new column (key=State.var). We can use spread() if we ever want to spread those columns back out. outL &lt;- out %&gt;% as.data.frame() %&gt;% pivot_longer( cols=-time, names_to=&quot;State.var&quot;, values_to=&quot;kg.N&quot;) ggplot(outL, aes(x=time, y=kg.N)) + geom_line() + facet_wrap(~State.var, scale=&quot;free_y&quot;) Figure 3.3: Dynamics of a simple N budget, based on Bormann et al. (1977). In some ways, we have been moderately successful in our first pass at converting a purely budgetary model into a dynamic process model. We mimicked total load, and see similar changes through time of all the state variables. Questions to ponder We replicated approximately the N budget of Bormann et al. (1977), but clearly vegetation cannot keep accumulating N indefinitely. What are our next steps? One logical step is to assume that as vegetation eventually gets limited by some factor or resource that is not in our model. If, at first approximation, the vegetation reaches a carrying capacity independent of high resource availability, we can use an approximation suggested by Soetaert and Hermann (2009) for self-limitation, \\[f(X)V\\left(1-\\frac{V}{K}\\right)\\] where \\(f(X)\\) is everything else that regulates mass-specific growth rate. Exercise Include self-limitation in your model of vegetation, estimate \\(K\\), and produce output. 3.6 Budget, take II Remember that following our template, we have a maximum rate times resource and self limitation, and inhibition. Currently, we have \\[\\frac{dV}{dt} = a_{1}AV - a_{2}V - a_3 V\\] and rearranging, \\[\\frac{dV}{dt} = \\left(a_{1}A - a_{2} - a_3\\right) V\\] If we add self-limitation, we get \\[\\frac{dV}{dt} = \\left(a_{1}A - a_{2} - a_3\\right) V \\left(1-\\frac{V}{K}\\right)\\] where \\(K\\) is the maximum amount of live vegetation that the ecosystem can sustain, in kg,N,ha\\(^{-1}\\). We don’t know exactly what that is yet, but we may be able to get estimates from the literature. For know we can pretend that it is just a bit more than was there in the mid-1970s, say, \\(K=600\\). Now we rewrite the R function with self-limitation. bormann2 &lt;- function(t, y, p) { # time, vector of state variables and parameters must be in this order # we can use as.list for both the state variables and parameters # a1 = uptake # a2 = loss from veg to avail # a3 = loss from veg to bound # a4 = net mineralization # a5 = export from avail # a6 = export from bound with( as.list( c(y, p) ), { dV.dt &lt;- (a1 * A - a2 - a3) * V * (1-V/K) dA.dt &lt;- i1 + a2 * V + a4 * B - a1 * A * V - a5 * A dB.dt &lt;- i2 + a3 * V - a4 * B - a6 * B # Here we return a list whose first element is the vector of # rates of change for the state variables. The first element must be these rates, # in the same order as the state variables in y # The second element is the total N in the system return(list( c(dV.dt, dA.dt, dB.dt), total = V + A + B ) )}) } We can add a new parameter to our vector of parameters, and then solve our new function bormann2 for the same time interval, and plot it. params[&quot;K&quot;] &lt;- 600 out &lt;- ode(y = initial.state, times=time, func=bormann2, parms = params) outL2 &lt;- out %&gt;% as.data.frame() %&gt;% pivot_longer(cols=-time, names_to=&quot;State.var&quot;, values_to=&quot;kg.N&quot;) ggplot(outL2, aes(time, kg.N)) + geom_line() + facet_wrap(~State.var, scale=&quot;free_y&quot;) Figure 3.4: Dynamics of an N budget, assuming density-dependence in vegetation with a fixed carrying capacity (Bormann et al. 1977). Unlike our first model of this system, we see state variables on curved trajectories and perhaps reaching asymptotes. This makes greater intuitive sense - over the short term, it is the same as the simple N budget shown in Bormann, Likens, and Melillo (1977) and it also shows a reasonable longterm trajectory for the vegetation, and the predicted consequences for the available and bound pools. References "],["lake-metabolism.html", "4 Lake Metabolism 4.1 Estimating Productivity 4.2 By hand, in R", " 4 Lake Metabolism In this chapter, you’ll study how lakes breath. You’ll get real data from Acton Lake, look it, and measure the rate of an inhale and an exhale. You’ll do that by hand, by hand with a spreadsheet, by hand with R, and finally using an R package, LakeMetabolizer, which is designed to do that and much more. 4.1 Estimating Productivity Most cells respire to do the work of growth and maintenance by consuming oxygen and using it as the final electron acceptor when O\\(_2\\) is reduced, creating water. Because individuals comprise cells, and ecosystems comprise individuals, ecosystems respire too, and we can measure their metabolic rate using oxygen consumption and production. We mesure ecosystem metabolic rate as net primary productivity which is the difference between gross primary productivity and respiration. Putting all of this in the same units of oxygen allows us to measure the rate, \\[NPP = GPP - R\\] If we assume that water column oxygen is correlated with the rates of photosynthesis, respiration, and net primary production, then we can think of the slopes of O vs. time as rates of respiration and net primary production. If we assume that respiration is constant throughout the 24 h cycle, we calculate GPP as the sum of NPP and R. 4.2 By hand, in R Let’s practice R by importing, wrangling, and graphing data, then calculating slopes and estimating respiration, NPP, and GPP. acton &lt;- read_csv(&quot;data/acton.csv&quot;, col_types = cols(date_time = col_datetime(format = &quot;%m/%d/%y %H:%M&quot;)), skip = 1# skips the first line of metadata ) summary(acton) ## date_time cum_h O_mg.L ## Min. :2013-06-27 06:15:00 Min. : 0.00 Min. : 4.530 ## 1st Qu.:2013-06-29 00:11:15 1st Qu.: 41.94 1st Qu.: 7.640 ## Median :2013-06-30 18:07:30 Median : 83.88 Median : 8.365 ## Mean :2013-06-30 18:07:30 Mean : 83.88 Mean : 8.607 ## 3rd Qu.:2013-07-02 12:03:45 3rd Qu.:125.81 3rd Qu.: 9.582 ## Max. :2013-07-04 06:00:00 Max. :167.75 Max. :12.700 ## O_perc temp ## Min. : 56.3 Min. :24.60 ## 1st Qu.: 96.4 1st Qu.:25.00 ## Median :107.6 Median :26.10 ## Mean :110.5 Mean :26.12 ## 3rd Qu.:123.2 3rd Qu.:27.10 ## Max. :167.1 Max. :28.10 Let’s check our understanding of lake oxygen dynamics by plotting the time series. Ggplot understands what to do with dates. ggplot(acton, aes(x=date_time, y=O_mg.L)) + geom_path() Figure 4.1: *Oxygen dynamics from Acton Lake. If we want to calculate the slope of the night time oxygen concentration, then we should identify what the endpoints of “day time” are so that we can do analyses on just daylight or nighttime data. Working with times is a little tricky, because times and dates, periods, durations, and intervals are inherently tricky. The date_time variable contains all the information, and we extra tidbits from it. # determine day/night intervals ## Start of day morning &lt;- 7 ## end of day evening &lt;- 19 acton &lt;- mutate(acton, date = as.factor( format(date_time, &quot;%Y-%m-%d&quot;) ), ## hour decimal format hour.d = as.integer( format(date_time, &quot;%H&quot;)) + as.numeric(format(date_time, &quot;%M&quot;))/60, day.d = ifelse(hour.d &gt;= morning &amp; hour.d &lt; evening, hour.d - morning, NA), night.d = ifelse( hour.d &gt;= evening, hour.d-evening, ifelse(hour.d &lt; morning, 24 - evening + hour.d, NA)), daylight = as.factor( ifelse(hour.d &gt;= morning &amp; hour.d &lt; evening, &quot;day&quot;, &quot;night&quot;)) ) ## with lubridate date(), hour(), minute() library(lubridate) acton &lt;- mutate(acton, date = as.factor( date(date_time) ), ## hour decimal format hour.d = hour(date_time) + minute(date_time)/60, day.d = ifelse(hour.d &gt;= morning &amp; hour.d &lt; evening, hour.d - morning, NA), night.d = ifelse( hour.d &gt;= evening, hour.d-evening, ifelse(hour.d &lt; morning, 24 - evening + hour.d, NA)), daylight = as.factor( ifelse(hour.d &gt;= morning &amp; hour.d &lt; evening, &quot;day&quot;, &quot;night&quot;)) ) # check # filter(acton, hour.d==3) The slope of oxygen concentration at night is respiration. Next we will pull out one day’s worth of data. acton2 &lt;- subset(acton, date_time &gt; &quot;2013-06-27 21:00:00&quot; &amp; date_time &lt; &quot;2013-06-28 06:15:00&quot;) qplot(x = date_time, O_mg.L, data=acton2, geom = &quot;path&quot;) Here is what each night looks like. nights &lt;- filter(acton, daylight==&quot;night&quot;) qplot(night.d, O_mg.L, data=nights, geom=&quot;point&quot;, colour=date) + geom_smooth(method=&quot;lm&quot;, se=FALSE) We can calculate the average slope for all nights, forcing a straight line through each night’s data. The estimates of uncertainty and the P values won’t make sense because the data are horribly autocorrelated, but we can rely on the estimates of the coefficients, and the average slope, in particular. m.resp &lt;- lm(O_mg.L ~ night.d + date, data=acton) summary(m.resp) ## ## Call: ## lm(formula = O_mg.L ~ night.d + date, data = acton) ## ## Residuals: ## Min 1Q Median 3Q Max ## -3.9649 -0.3722 0.0813 0.3683 2.1803 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.42500 0.17214 60.563 &lt; 2e-16 *** ## night.d -0.17335 0.01291 -13.425 &lt; 2e-16 *** ## date2013-06-28 -0.51592 0.20392 -2.530 0.0119 * ## date2013-06-29 0.14137 0.20392 0.693 0.4886 ## date2013-06-30 -0.86051 0.20392 -4.220 3.17e-05 *** ## date2013-07-01 -1.81634 0.20392 -8.907 &lt; 2e-16 *** ## date2013-07-02 -2.43509 0.20392 -11.941 &lt; 2e-16 *** ## date2013-07-03 -1.54342 0.20392 -7.569 3.87e-13 *** ## date2013-07-04 0.08223 0.23686 0.347 0.7287 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.7955 on 327 degrees of freedom ## (336 observations deleted due to missingness) ## Multiple R-squared: 0.6543, Adjusted R-squared: 0.6458 ## F-statistic: 77.36 on 8 and 327 DF, p-value: &lt; 2.2e-16 The estimate for night.d, r round(coef(m.resp)[2],3), is our estimate of the respiration rate. If you would like you could perform similar analyses on a subset of the data. acton2 &lt;- acton %&gt;% filter(date %in% c(&quot;2013-06-28&quot;, &quot;2013-06-29&quot;) ) m.resp2 &lt;- lm(O_mg.L ~ night.d + date, data=acton2) summary(m.resp2) ## ## Call: ## lm(formula = O_mg.L ~ night.d + date, data = acton2) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.1718 -0.8263 0.1213 0.6559 1.5473 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.71318 0.18270 58.638 &lt; 2e-16 *** ## night.d -0.31022 0.02389 -12.988 &lt; 2e-16 *** ## date2013-06-29 0.65729 0.16545 3.973 0.00014 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.8105 on 93 degrees of freedom ## (96 observations deleted due to missingness) ## Multiple R-squared: 0.6648, Adjusted R-squared: 0.6576 ## F-statistic: 92.23 on 2 and 93 DF, p-value: &lt; 2.2e-16 # install.packages(&quot;LakeMetabolizer&quot;, dep=TRUE) library(LakeMetabolizer) names(acton) k.gas &lt;- 0.4 z.mix &lt;- 1 irr acton.LM &lt;- acton %&gt;% mutate(z.mix = z.mix, k.gas = k.gas ) %&gt;% select(datetime=date_time, do.obs=O_mg.L, do.sat=O_perc, k.gas=k.gas, z.mix=z.mix ) str(acton.LM) summary(acton.LM) write.csv(acton.LM, &quot;act.csv&quot;, row.names=FALSE) acton.L &lt;- read.csv(&quot;act.csv&quot;, colClasses=c(&quot;POSIXct&quot;, rep(&quot;numeric&quot;, 3))) n &lt;- nrow(acton.L) acton.LM &lt;- acton.L %&gt;% mutate(k.gas = k.gas, z.mix = 1, ) irr &lt;- (1500*sin(2*pi*(1/n )*(1:(n*2))+1.5*pi) + 650 + rnorm(n*2, 0, 0.25)) * ifelse(is.day(acton.L$datetime, 39.5668), 1, 0) plot(irr) acton.LM &lt;- acton.L %&gt;% mutate(k.gas = k.gas, z.mix = 1, irr=irr) str(acton.LM) out &lt;- metab(acton.LM, method=&quot;bookkeep&quot;) "],["MEL.html", "5 Multiple Element Limitation 5.1 Rastetter et al. 1997 5.2 Implementing MEL", " 5 Multiple Element Limitation 5.1 Rastetter et al. 1997 Readings: Chapters 1, 2 Bormann, Likens, and Melillo (1977) Rastetter, Agren, and Shaver (1997) Soetaert and Herman (2009), pages … Rastetter and Shaver (1992) proposed a model of multiple-element limitation of vegetation growth (MEL). Rastetter, Agren, and Shaver (1997) extended that to include soil pools. We replicate this here. It is similar to our model of (Bormann, Likens, and Melillo 1977), but now includes both carbon and nitrogen.2 By now, you’ve had some practice working with models, so take a gander at this one (Fig. 5.1). Figure 5.1: Fig. 1 from Rastetter et al. 1997. Variables \\(B\\), \\(E\\), and \\(D\\) elements in vegetation biomass, inorganic form (e.g., soil solution, or atmospheric CO\\(_2\\)), and organic form in soil detritus. Variable \\(V_i\\) is allocation related to nutrient acquistion. \\(U\\) is uptake by vegetation or microbes in detritus (broadly defined), \\(R_N\\) is deposition, and \\(L_N\\) is loss via leaching or denitrification. \\(R\\) is renewal into the inorganic pools. The little triangles or bowties on fluxes refer to some rate-controlling function; \\(B\\) and \\(V\\) exchange information (dotted lines) that influences fluxes. Other terms are explained in the Table below. Figure 5.2: Table 1 (Rastetter et al 1997). MEL uses the parameter \\(A\\) for “acclimation”, which we can think of as compensation by vegetation that is associated with homeostatic responses to resource supply rates that differ from a stoichiometric ideal. Acclimation has a perfectly good meaning in ecophysiology, which is short- to near-term reversible physiological adjustment in response to changing conditions. In MEL, “acclimation” is much broader, and this early version, it means shifts in the relative rates of C and N accumulation in vegetation, resulting in and from changes in the C:N ratio of vegetation. This occurs due to the ratio of wood to non-woody tissue, defined by \\(q\\). Compensatory dynamics by vegetation, or “acclimation”, is a very important part of this model. “Vegetation” is a complex adaptive system that undergoes diverse changes across many time scales. This could happen through physiological, ecological, and evolutionary changes in plant species composition, ratios of root, stem, leaves and reproductive structures, or changes in tissue C:N ratios. “Acclimation” covers a range of responses with very different time scales, and the variable \\(A\\) is how these changes are incorporated into this ecosystem model. In a later section, we explore the meaning and implications of MEL acclimation. In MEL, vegetation “acclimates” through differential allocation to carbon vs. nitrogen uptake functions. Rastetter et al. refers to this as uptake “effort”. They use this anthropomorphic term “effort” for a pattern of allocation, as in “…increasing uptake effort to acquire limiting soil nutrients.” MEL uses the state variables, \\(V_C\\) and \\(V_N\\), to represent this “effort” or allocation of uptake of C and N respectively. In a later section, we explore the meaning and implications of MEL effort. Both vegetation and microbes acclimate in MEL, in a manner inversely proportion to the relative concentrations of nutrients. In both vegetation and microbes, this results in a tendency toward maintenance of optimal C:N ratios. However, the model handles them differently. It assumes that the acclimation in vegetation is slow while the acclimation in microbes is instantaneous. Here we write out the model nearly as written in Rastetter et al. (1997), but with some reordering. By default, R is an interpreted language rather than a compiled language. What that means for us is that R processes commands one line at a time. Therefore, if a function F requires parameter x, we have to make sure parameter x is defined before we define F. In our implementation of MEL below, Mc requires Ucm, so Ucm needs to be defined before Mc. Copy this into a new script and name it ‘mel2.R’. In that script, add more comments to those I started. When you save that script, you can use source('mel2.R') to load the function. mel2 &lt;- function(time, y, p){ with(as.list(c(y,p)), { ## Carbon is 1 and Nitrogen is 2 in ## E - inorganic; D - soil organic w/ microbes; B - veg biomass; ## V - acclimation ## Fig. 1 of Rastetter et al. (1997) ## Gross UPTAKE of inorganic nutrients by Microbes ## Note rearrangement of terms (cf. Rastetter et al. 1997) ## (uptake) X (carbon availability) X (stoichiometric optimization) Unm &lt;- alpha_n*En/(k_nm + En) * psi*Dc * Dc/(theta*Dn) Ucm &lt;- alpha_c*Ec/(k_cm + Ec) * psi*Dn * (theta*Dn)/Dc # alpha_c=0 ## Microbial consumption ## nutrient availability + gross uptake Mc &lt;- psi*Dc + Ucm Mn &lt;- psi*Dn + Unm Alpha_c &lt;- epsilon_c * theta*Mn/(Mc + theta*Mn) Alpha_n &lt;- epsilon_n * Mc/(Mc + theta*Mn) ## C:N ratio (units of C) q &lt;- q_w*Bc/(k_q + Bc) ## SURFACE area related to nutrient acquisition (0 &lt; z &lt; 1) Sc &lt;- (Bc + q*Bn)^zc Sn &lt;- (Bc + q*Bn)^zn ## UPTAKE by Vegetation ## uptake constant X rel. effort X Surface area X resource conc. Ucv &lt;- gc * Vc * Sc * Ec/(kc + Ec) Unv &lt;- gn * Vn * Sn * En/(kn + En) ## LOSSES Lcv &lt;- mc*Bc Lnv &lt;- mn*Bn Lce &lt;- beta_ce * Ec # beta_ce = 0 # export = 0 Lne &lt;- beta_ne * En # leaching or denitrification Lcd &lt;- beta_d * Dc Lnd &lt;- beta_d * Dn ## REPLENISHMENT to the inorganic pools (R) Rcm &lt;- Mc*(1-Alpha_c) # C respiration Rnm &lt;- Mn*(1-Alpha_n) # N mineralization Rcv &lt;- rc*Bc Rnv &lt;- rn*Bn ## Available elemental nutrients ## Set dE_i/dt = 0 to control the inorganic pools externally dE_N &lt;- Rne + Rnm + Rnv - Lne - Unm - Unv ## dE_C &lt;- Rce + Rcm + Rcv - Lce - Ucm - Ucv dE_C &lt;- 0 ## Nutrients in vegetation BIOMASS dB_C &lt;- Ucv - Rcv - Lcv dB_N &lt;- Unv - Rnv - Lnv ## Nutrients in DETRITUS dD_C &lt;- Lcv + Ucm - Lcd - Rcm dD_N &lt;- Lnv + Unm - Lnd - Rnm ## Acclimation (compensation) potential ## mass-specific growth rates Grc &lt;- dB_C/Bc Grn &lt;- dB_N/Bn ## symmetric C:N differential plus relative growth difference A &lt;- log(Bc/(q*Bn)) + tau * (Grc - Grn) ## Relative effort toward compensation ## if(A&gt;0) Vstar &lt;- Vc else Vstar &lt;- Vn Vstar &lt;- (A &gt; 0) * Vc + (A &lt; 0) * Vn dV_C &lt;- -1*a*A*Vstar dV_N &lt;- -1 * dV_C ## Auxiliary ecosystem variables NPP &lt;- Ucv - Rcv Net_N_uptake &lt;- Unv - Rnv Ecosystem_N=Bn+En+Dn Ecosystem_C=Bc+Ec+Dc return(list(c(dE_C, dE_N, dB_C, dB_N, dD_C, dD_N, dV_C, dV_N), NPP=NPP, Net_N_uptake=Net_N_uptake, Ecosystem_C=Ecosystem_C) ) }) } Here we start with a vector of model parameters whose description and units are found in Table 1 above. The numeric values come from Table 2 in Rastetter et al. (1997). You should copy these into your own script, and then add your own comments to each parameter, as I started to. ## Parameter set for a closed ecosystem p.c &lt;- c( # carbon, nitrogen Rce=0, Rne=0, # no renewal from outside the ecosystem gc=1116, gn =23.77, rc=0.02055, rn=0.01955, mc=0.02055, mn=0.08009, kc=350, kn=5, zc=0.11, zn=0.16, epsilon_c=0.6, epsilon_n=0.6471, alpha_c=0, alpha_n = 0.01092, k_cm = 1, k_nm=1, beta_ce = 0, beta_ne = 0, # Other a=5, tau=3, # damping coef q_w=439, k_q=26290, theta=8.628, psi=0.04321, beta_d=0 ) Exercise To help you better grasp what is going on in the model, redraw Fig. 5.1 on a chalkboard or a larger piece of paper and add as much detail as you can fit. Include model parameters and definitions and explanations – whatever helps you make sense of the processes, and their mathematical representation. 5.2 Implementing MEL Table 2 of Rastetter et al. also include initial values for the state variables, which we include here. init.states &lt;- c(Ec=350, En=1, # Inorganic nutrients g/m^2 Bc=22000, Bn=110, # Biomass nutrients g/m^2 Dc=13000, Dn=521, # Detritus nutrients g/m^2 Vc=0.5, Vn=0.5 # allocation &quot;effort&quot; unitless ) In addition to initial values of state variables, Rastetter, Agren, and Shaver (1997) (Table 2) list initial fluxes. We don’t have to worry about those; the model calculates the initial fluxes from parameters and from initial values of the state variables. 5.2.1 Increasing atmospheric carbon with events in ode() Rastetter et al. (1997) double CO\\(_2\\) concemntrations at an early time point in their simulations. We do that using an events in the ode() function. An “event” in an ode() model the value of a state variable changes suddenly at a one or more time points. In one sense, these are like ecological disturbances. For instance, we could add 1 kilogram of phosphorus to a lake in a one-time pulse, or halve primary producer biomass at 10 random times over a one hundred year interval. We can create events using either a function, or with a data frame. Here we create a data frame, using the required four variables: ‘var’ selects the state variable to change. ‘time’ is the time at which the event occurs. ‘value’ is the numeric value associated with the change. ‘method’ is the operator that operates on the ‘value’ and the state variable: ‘add’ will add the value to the state variable, ‘mult’ will multiply the state variable by the value, and ‘replace’ will simply replace the state variable with the value (the value can be a positive or negative number). event.df &lt;- data.frame(var=&quot;Ec&quot;, time=0.005, value=2, method=&quot;mult&quot;) This event will double atmospheric carbon concentration very shortly after the start of the simulation. We will run the model for 1000 years as in Rastetter et al. (1997), and specify that R return values for a logarithm series of time steps. ## 10^3 = 1000 years t=10^seq(-3, 3, by=.001) Next we run the model using parameters for a closed ecosystem, and a partly open system (Rastetter, Agren, and Shaver 1997). ## Closed ecosystem out.c &lt;- ode(init.states, t, func=mel2, parms=p.c, events=list(data=event.df) ) ## Partly open p.o &lt;- p.c p.o[&quot;Rne&quot;] &lt;- 1 p.o[&quot;beta_ne&quot;] &lt;- 1 out.o &lt;- ode(init.states, t, func=mel2, parms=p.o, events = list(data = event.df) ) You will probably get a warning message that R has included our event time into the integration procedure. That is a good thing. Next we convert the simulation data sets, add variables, combine, rearrange, and plot the results. out.c &lt;- out.c %&gt;% as.data.frame() %&gt;% mutate(N.cycle = &quot;closed&quot;) out.o &lt;- out.o %&gt;% as.data.frame() %&gt;% mutate(N.cycle = &quot;open&quot;) out.all &lt;- rbind(out.c, out.o) outL &lt;- pivot_longer(out.all, cols=-c(time, N.cycle), names_to=&quot;State_var&quot;, values_to=&quot;g.sq.m&quot;) ggplot(outL, aes(x=time, y=g.sq.m, colour=N.cycle)) + geom_line() + scale_x_log10() + facet_wrap(~State_var, ncol=3, scales=&quot;free&quot;) Figure 5.3: Simulated dynamics of carbon and nitrogen in an ecosystem with both C- and N-limitation, in a closed and partly open ecosystem. Recreates Fig. 3 from Rastetter et al. (1997), in part. Cool, right? References "],["references.html", "6 References", " 6 References "]]
